"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/users/page",{

/***/ "(app-pages-browser)/./lib/users-api.ts":
/*!**************************!*\
  !*** ./lib/users-api.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   assignCompanyToUser: () => (/* binding */ assignCompanyToUser),\n/* harmony export */   assignProfileToUser: () => (/* binding */ assignProfileToUser),\n/* harmony export */   createUser: () => (/* binding */ createUser),\n/* harmony export */   deleteUser: () => (/* binding */ deleteUser),\n/* harmony export */   deleteUserApplicationAccess: () => (/* binding */ deleteUserApplicationAccess),\n/* harmony export */   deleteUserCompany: () => (/* binding */ deleteUserCompany),\n/* harmony export */   fetchApplications: () => (/* binding */ fetchApplications),\n/* harmony export */   fetchCompaniesForUsers: () => (/* binding */ fetchCompaniesForUsers),\n/* harmony export */   fetchProfile: () => (/* binding */ fetchProfile),\n/* harmony export */   fetchProfiles: () => (/* binding */ fetchProfiles),\n/* harmony export */   fetchUser: () => (/* binding */ fetchUser),\n/* harmony export */   fetchUserApplicationAccess: () => (/* binding */ fetchUserApplicationAccess),\n/* harmony export */   fetchUserCompanies: () => (/* binding */ fetchUserCompanies),\n/* harmony export */   fetchUserProfiles: () => (/* binding */ fetchUserProfiles),\n/* harmony export */   fetchUsers: () => (/* binding */ fetchUsers),\n/* harmony export */   removeCompanyFromUser: () => (/* binding */ removeCompanyFromUser),\n/* harmony export */   removeProfileFromUser: () => (/* binding */ removeProfileFromUser),\n/* harmony export */   transformApiUserToPortalUser: () => (/* binding */ transformApiUserToPortalUser),\n/* harmony export */   updateUser: () => (/* binding */ updateUser)\n/* harmony export */ });\n// Use Next.js API routes as proxy to backend\nconst DATA_API_BASE_URL = \"/api\";\n// Fetch all users from API\nasync function fetchUsers() {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users\"));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        // Handle both API format variants\n        if (data.users) {\n            // Transform from portal format to User interface format\n            return data.users.map((user)=>{\n                var _user_tenants;\n                return {\n                    user_id: user.id || user.user_id,\n                    username: user.name || user.username || user.full_name,\n                    email: user.email,\n                    full_name: user.name || user.full_name,\n                    status: user.status === 'active' ? 'active' : 'inactive',\n                    created_at: new Date().toISOString(),\n                    companies_count: ((_user_tenants = user.tenants) === null || _user_tenants === void 0 ? void 0 : _user_tenants.length) || 0,\n                    profiles: user.profiles || []\n                };\n            });\n        }\n        return [];\n    } catch (error) {\n        console.error('Error fetching users:', error);\n        return [];\n    }\n}\n// Fetch single user by ID\nasync function fetchUser(userId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.user || null;\n    } catch (error) {\n        console.error('Error fetching user:', error);\n        return null;\n    }\n}\n// Fetch all applications\nasync function fetchApplications() {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/applications\"));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.database_applications || [];\n    } catch (error) {\n        console.error('Error fetching applications:', error);\n        return [];\n    }\n}\n// Create new user\nasync function createUser(userData) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(userData)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.user || null;\n    } catch (error) {\n        console.error('Error creating user:', error);\n        return null;\n    }\n}\n// Update user\nasync function updateUser(userId, userData) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId), {\n            method: 'PUT',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(userData)\n        });\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.user || null;\n    } catch (error) {\n        console.error('Error updating user:', error);\n        return null;\n    }\n}\n// Delete user\nasync function deleteUser(userId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId), {\n            method: 'DELETE'\n        });\n        return response.ok;\n    } catch (error) {\n        console.error('Error deleting user:', error);\n        return false;\n    }\n}\n// === NOWE FUNKCJE DLA PROFILI ===\n// Fetch all profiles (optionally filtered by application)\nasync function fetchProfiles(applicationId) {\n    try {\n        const url = applicationId ? \"\".concat(DATA_API_BASE_URL, \"/profiles?application=\").concat(applicationId) : \"\".concat(DATA_API_BASE_URL, \"/profiles\");\n        const response = await fetch(url);\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.profiles || [];\n    } catch (error) {\n        console.error('Error fetching profiles:', error);\n        return [];\n    }\n}\n// Fetch single profile with role mappings\nasync function fetchProfile(profileId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/profiles/\").concat(profileId));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.profile || null;\n    } catch (error) {\n        console.error('Error fetching profile:', error);\n        return null;\n    }\n}\n// Fetch companies for user access management\nasync function fetchCompaniesForUsers() {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/companies\"));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.companies || [];\n    } catch (error) {\n        console.error('Error fetching companies:', error);\n        return [];\n    }\n}\n// Assign profile to user\nasync function assignProfileToUser(userId, profileId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/profiles\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                profile_id: profileId\n            })\n        });\n        return response.ok;\n    } catch (error) {\n        console.error('Error assigning profile to user:', error);\n        return false;\n    }\n}\n// Remove profile from user\nasync function removeProfileFromUser(userId, profileId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/profiles/\").concat(profileId), {\n            method: 'DELETE'\n        });\n        return response.ok;\n    } catch (error) {\n        console.error('Error removing profile from user:', error);\n        return false;\n    }\n}\n// Assign company to user\nasync function assignCompanyToUser(userId, companyId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/companies\"), {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify({\n                company_id: companyId\n            })\n        });\n        return response.ok;\n    } catch (error) {\n        console.error('Error assigning company to user:', error);\n        return false;\n    }\n}\n// Remove company from user\nasync function removeCompanyFromUser(userId, companyId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/companies/\").concat(companyId), {\n            method: 'DELETE'\n        });\n        return response.ok;\n    } catch (error) {\n        console.error('Error removing company from user:', error);\n        return false;\n    }\n}\n// Fetch user's assigned profiles\nasync function fetchUserProfiles(userId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/profiles\"));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        return data.profiles || [];\n    } catch (error) {\n        console.error('Error fetching user profiles:', error);\n        return [];\n    }\n}\n// Transform API user to Portal user format\nfunction transformApiUserToPortalUser(apiUser, index) {\n    return {\n        id: index + 1,\n        user_id: apiUser.user_id,\n        name: apiUser.full_name,\n        email: apiUser.email,\n        phone: \"-\",\n        companies: apiUser.companies_count || 0,\n        permissions: apiUser.user_id.includes('admin') ? 'Administrator' : 'Użytkownik',\n        profiles: apiUser.profiles || [],\n        status: apiUser.status === 'active'\n    };\n}\n// Fetch user's application access (real data from API)\nasync function fetchUserApplicationAccess(userId) {\n    try {\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/application-access\"));\n        if (!response.ok) {\n            throw new Error(\"HTTP error! status: \".concat(response.status));\n        }\n        const data = await response.json();\n        // Przekształć zagnieżdżone dane API na płaską listę\n        const applications = data.applications || [];\n        const flattenedAccess = [];\n        applications.forEach((app)=>{\n            var _app_profiles;\n            (_app_profiles = app.profiles) === null || _app_profiles === void 0 ? void 0 : _app_profiles.forEach((profile)=>{\n                flattenedAccess.push({\n                    user_id: userId,\n                    app_id: app.app_id,\n                    app_name: app.app_name,\n                    profile_id: profile.profile_id,\n                    profile_name: profile.profile_name,\n                    assigned_at: profile.assigned_at,\n                    assigned_by: profile.assigned_by\n                });\n            });\n        });\n        return flattenedAccess;\n    } catch (error) {\n        console.error('Error fetching user application access:', error);\n        throw error;\n    }\n}\n// Delete user application access by profile_id\nasync function deleteUserApplicationAccess(userId, profileId) {\n    try {\n        console.log('Deleting application access:', {\n            userId,\n            profileId\n        });\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/application-access/\").concat(profileId), {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        console.log('Delete response status:', response.status);\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || errorData.detail || 'Failed to delete application access');\n        }\n        const result = await response.json();\n        console.log('Delete success:', result);\n    } catch (error) {\n        console.error('Error deleting user application access:', error);\n        throw error;\n    }\n}\n// Fetch user companies\nasync function fetchUserCompanies(userId) {\n    try {\n        console.log('Fetching user companies for user:', userId);\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/companies\"), {\n            method: 'GET',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        console.log('User companies response status:', response.status);\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || errorData.detail || 'Failed to fetch user companies');\n        }\n        const data = await response.json();\n        console.log('User companies fetched:', data);\n        // Map API response to UserCompanyAccess format\n        const companies = data.companies || [];\n        return companies.map((company)=>({\n                company_id: company.company_id,\n                company_name: company.company_name,\n                assigned_date: company.assigned_at,\n                nip: company.nip\n            }));\n    } catch (error) {\n        console.error('Error fetching user companies:', error);\n        throw error;\n    }\n}\n// Delete user company access\nasync function deleteUserCompany(userId, companyId) {\n    try {\n        console.log('Deleting user company access:', {\n            userId,\n            companyId\n        });\n        const response = await fetch(\"\".concat(DATA_API_BASE_URL, \"/users/\").concat(userId, \"/companies/\").concat(companyId), {\n            method: 'DELETE',\n            headers: {\n                'Content-Type': 'application/json'\n            }\n        });\n        console.log('Delete company response status:', response.status);\n        if (!response.ok) {\n            const errorData = await response.json();\n            throw new Error(errorData.error || errorData.detail || 'Failed to delete user company access');\n        }\n        console.log('User company access deleted successfully');\n    } catch (error) {\n        console.error('Error deleting user company access:', error);\n        throw error;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cy9vcGFfemVyb19wb2xsL2xpYi91c2Vycy1hcGkudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVXNlIE5leHQuanMgQVBJIHJvdXRlcyBhcyBwcm94eSB0byBiYWNrZW5kXG5jb25zdCBEQVRBX0FQSV9CQVNFX1VSTCA9IFwiL2FwaVwiXG5cbi8vIFVzZXIgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFVzZXIge1xuICB1c2VyX2lkOiBzdHJpbmdcbiAgdXNlcm5hbWU6IHN0cmluZ1xuICBlbWFpbDogc3RyaW5nXG4gIGZ1bGxfbmFtZTogc3RyaW5nXG4gIHN0YXR1czogJ2FjdGl2ZScgfCAnaW5hY3RpdmUnXG4gIGNyZWF0ZWRfYXQ6IHN0cmluZ1xuICB1cGRhdGVkX2F0Pzogc3RyaW5nXG4gIGNvbXBhbmllc19jb3VudD86IG51bWJlclxuICBwcm9maWxlcz86IEFycmF5PHtcbiAgICBhcHA6IHN0cmluZ1xuICAgIG5hbWU6IHN0cmluZ1xuICB9PlxufVxuXG4vLyBBcHBsaWNhdGlvbiBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgQXBwbGljYXRpb24ge1xuICBhcHBfaWQ6IHN0cmluZ1xuICBhcHBfbmFtZTogc3RyaW5nXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgcHJvZmlsZXM6IEFycmF5PHtcbiAgICBwcm9maWxlX2lkOiBzdHJpbmdcbiAgICBwcm9maWxlX25hbWU6IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICBpc19kZWZhdWx0OiBib29sZWFuXG4gIH0+XG4gIHN0YXR1czogc3RyaW5nXG59XG5cbi8vIFByb2ZpbGUgaW50ZXJmYWNlXG5leHBvcnQgaW50ZXJmYWNlIFByb2ZpbGUge1xuICBwcm9maWxlX2lkOiBzdHJpbmdcbiAgYXBwX2lkOiBzdHJpbmdcbiAgcHJvZmlsZV9uYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBpc19kZWZhdWx0OiBib29sZWFuXG4gIGFwcF9uYW1lOiBzdHJpbmdcbiAgY3JlYXRlZF9hdDogc3RyaW5nXG4gIHJvbGVfbWFwcGluZ3M6IEFycmF5PHtcbiAgICByb2xlX2lkOiBzdHJpbmdcbiAgICByb2xlX25hbWU6IHN0cmluZ1xuICAgIGRlc2NyaXB0aW9uOiBzdHJpbmdcbiAgICBwZXJtaXNzaW9uczogQXJyYXk8e1xuICAgICAgcGVybWlzc2lvbl9pZDogc3RyaW5nXG4gICAgICBwZXJtaXNzaW9uX25hbWU6IHN0cmluZ1xuICAgICAgZGVzY3JpcHRpb246IHN0cmluZ1xuICAgIH0+XG4gIH0+XG59XG5cbi8vIFVzZXIgUHJvZmlsZSBpbnRlcmZhY2VcbmV4cG9ydCBpbnRlcmZhY2UgVXNlclByb2ZpbGUge1xuICB1c2VyX2lkOiBzdHJpbmdcbiAgcHJvZmlsZV9pZDogc3RyaW5nXG4gIGFwcF9pZDogc3RyaW5nXG4gIGFzc2lnbmVkX2F0OiBzdHJpbmdcbiAgYXNzaWduZWRfYnk/OiBzdHJpbmdcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb21wYW55IHtcbiAgY29tcGFueV9pZDogc3RyaW5nXG4gIGNvbXBhbnlfbmFtZTogc3RyaW5nXG4gIG5pcDogc3RyaW5nXG4gIHN0YXR1czogc3RyaW5nXG59XG5cbi8vIEZldGNoIGFsbCB1c2VycyBmcm9tIEFQSVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVXNlcnMoKTogUHJvbWlzZTxVc2VyW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vyc2ApXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBcbiAgICAvLyBIYW5kbGUgYm90aCBBUEkgZm9ybWF0IHZhcmlhbnRzXG4gICAgaWYgKGRhdGEudXNlcnMpIHtcbiAgICAgIC8vIFRyYW5zZm9ybSBmcm9tIHBvcnRhbCBmb3JtYXQgdG8gVXNlciBpbnRlcmZhY2UgZm9ybWF0XG4gICAgICByZXR1cm4gZGF0YS51c2Vycy5tYXAoKHVzZXI6IGFueSkgPT4gKHtcbiAgICAgICAgdXNlcl9pZDogdXNlci5pZCB8fCB1c2VyLnVzZXJfaWQsXG4gICAgICAgIHVzZXJuYW1lOiB1c2VyLm5hbWUgfHwgdXNlci51c2VybmFtZSB8fCB1c2VyLmZ1bGxfbmFtZSxcbiAgICAgICAgZW1haWw6IHVzZXIuZW1haWwsXG4gICAgICAgIGZ1bGxfbmFtZTogdXNlci5uYW1lIHx8IHVzZXIuZnVsbF9uYW1lLFxuICAgICAgICBzdGF0dXM6IHVzZXIuc3RhdHVzID09PSAnYWN0aXZlJyA/ICdhY3RpdmUnIDogJ2luYWN0aXZlJyxcbiAgICAgICAgY3JlYXRlZF9hdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLCAvLyBOb3QgYXZhaWxhYmxlIGluIHBvcnRhbCBmb3JtYXRcbiAgICAgICAgY29tcGFuaWVzX2NvdW50OiB1c2VyLnRlbmFudHM/Lmxlbmd0aCB8fCAwLFxuICAgICAgICBwcm9maWxlczogdXNlci5wcm9maWxlcyB8fCBbXVxuICAgICAgfSkpXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHVzZXJzOicsIGVycm9yKVxuICAgIHJldHVybiBbXVxuICB9XG59XG5cbi8vIEZldGNoIHNpbmdsZSB1c2VyIGJ5IElEXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVc2VyKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyIHwgbnVsbD4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7REFUQV9BUElfQkFTRV9VUkx9L3VzZXJzLyR7dXNlcklkfWApXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4gZGF0YS51c2VyIHx8IG51bGxcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyOicsIGVycm9yKVxuICAgIHJldHVybiBudWxsXG4gIH1cbn1cblxuLy8gRmV0Y2ggYWxsIGFwcGxpY2F0aW9uc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoQXBwbGljYXRpb25zKCk6IFByb21pc2U8QXBwbGljYXRpb25bXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7REFUQV9BUElfQkFTRV9VUkx9L2FwcGxpY2F0aW9uc2ApXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBIVFRQIGVycm9yISBzdGF0dXM6ICR7cmVzcG9uc2Uuc3RhdHVzfWApXG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICByZXR1cm4gZGF0YS5kYXRhYmFzZV9hcHBsaWNhdGlvbnMgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBhcHBsaWNhdGlvbnM6JywgZXJyb3IpXG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuLy8gQ3JlYXRlIG5ldyB1c2VyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlVXNlcih1c2VyRGF0YToge1xuICB1c2VybmFtZTogc3RyaW5nXG4gIGVtYWlsOiBzdHJpbmdcbiAgZnVsbF9uYW1lOiBzdHJpbmdcbiAgcGFzc3dvcmQ6IHN0cmluZ1xuICB0ZW5hbnRfaWQ6IHN0cmluZ1xuICByb2xlPzogJ0FkbWluaXN0cmF0b3InIHwgJ1XFvHl0a293bmlrJ1xufSk6IFByb21pc2U8VXNlciB8IG51bGw+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vyc2AsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHVzZXJEYXRhKSxcbiAgICB9KVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgcmV0dXJuIGRhdGEudXNlciB8fCBudWxsXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgdXNlcjonLCBlcnJvcilcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG5cbi8vIFVwZGF0ZSB1c2VyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlVXNlcih1c2VySWQ6IHN0cmluZywgdXNlckRhdGE6IFBhcnRpYWw8VXNlcj4pOiBQcm9taXNlPFVzZXIgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtEQVRBX0FQSV9CQVNFX1VSTH0vdXNlcnMvJHt1c2VySWR9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh1c2VyRGF0YSksXG4gICAgfSlcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhLnVzZXIgfHwgbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIHVzZXI6JywgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBEZWxldGUgdXNlclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXIodXNlcklkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgIH0pXG4gICAgcmV0dXJuIHJlc3BvbnNlLm9rXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdXNlcjonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyA9PT0gTk9XRSBGVU5LQ0pFIERMQSBQUk9GSUxJID09PVxuXG4vLyBGZXRjaCBhbGwgcHJvZmlsZXMgKG9wdGlvbmFsbHkgZmlsdGVyZWQgYnkgYXBwbGljYXRpb24pXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hQcm9maWxlcyhhcHBsaWNhdGlvbklkPzogc3RyaW5nKTogUHJvbWlzZTxQcm9maWxlW10+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB1cmwgPSBhcHBsaWNhdGlvbklkIFxuICAgICAgPyBgJHtEQVRBX0FQSV9CQVNFX1VSTH0vcHJvZmlsZXM/YXBwbGljYXRpb249JHthcHBsaWNhdGlvbklkfWBcbiAgICAgIDogYCR7REFUQV9BUElfQkFTRV9VUkx9L3Byb2ZpbGVzYFxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgcmV0dXJuIGRhdGEucHJvZmlsZXMgfHwgW11cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBwcm9maWxlczonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBGZXRjaCBzaW5nbGUgcHJvZmlsZSB3aXRoIHJvbGUgbWFwcGluZ3NcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFByb2ZpbGUocHJvZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPFByb2ZpbGUgfCBudWxsPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtEQVRBX0FQSV9CQVNFX1VSTH0vcHJvZmlsZXMvJHtwcm9maWxlSWR9YClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhLnByb2ZpbGUgfHwgbnVsbFxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHByb2ZpbGU6JywgZXJyb3IpXG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuXG4vLyBGZXRjaCBjb21wYW5pZXMgZm9yIHVzZXIgYWNjZXNzIG1hbmFnZW1lbnRcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaENvbXBhbmllc0ZvclVzZXJzKCk6IFByb21pc2U8Q29tcGFueVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtEQVRBX0FQSV9CQVNFX1VSTH0vY29tcGFuaWVzYClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhLmNvbXBhbmllcyB8fCBbXVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGNvbXBhbmllczonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBBc3NpZ24gcHJvZmlsZSB0byB1c2VyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXNzaWduUHJvZmlsZVRvVXNlcih1c2VySWQ6IHN0cmluZywgcHJvZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH0vcHJvZmlsZXNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHByb2ZpbGVfaWQ6IHByb2ZpbGVJZFxuICAgICAgfSksXG4gICAgfSlcbiAgICByZXR1cm4gcmVzcG9uc2Uub2tcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhc3NpZ25pbmcgcHJvZmlsZSB0byB1c2VyOicsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIFJlbW92ZSBwcm9maWxlIGZyb20gdXNlclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZVByb2ZpbGVGcm9tVXNlcih1c2VySWQ6IHN0cmluZywgcHJvZmlsZUlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH0vcHJvZmlsZXMvJHtwcm9maWxlSWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICB9KVxuICAgIHJldHVybiByZXNwb25zZS5va1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHByb2ZpbGUgZnJvbSB1c2VyOicsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIEFzc2lnbiBjb21wYW55IHRvIHVzZXJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhc3NpZ25Db21wYW55VG9Vc2VyKHVzZXJJZDogc3RyaW5nLCBjb21wYW55SWQ6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7REFUQV9BUElfQkFTRV9VUkx9L3VzZXJzLyR7dXNlcklkfS9jb21wYW5pZXNgLCB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIGNvbXBhbnlfaWQ6IGNvbXBhbnlJZFxuICAgICAgfSksXG4gICAgfSlcbiAgICByZXR1cm4gcmVzcG9uc2Uub2tcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhc3NpZ25pbmcgY29tcGFueSB0byB1c2VyOicsIGVycm9yKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8vIFJlbW92ZSBjb21wYW55IGZyb20gdXNlclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlbW92ZUNvbXBhbnlGcm9tVXNlcih1c2VySWQ6IHN0cmluZywgY29tcGFueUlkOiBzdHJpbmcpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH0vY29tcGFuaWVzLyR7Y29tcGFueUlkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgfSlcbiAgICByZXR1cm4gcmVzcG9uc2Uub2tcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW1vdmluZyBjb21wYW55IGZyb20gdXNlcjonLCBlcnJvcilcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vLyBGZXRjaCB1c2VyJ3MgYXNzaWduZWQgcHJvZmlsZXNcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBmZXRjaFVzZXJQcm9maWxlcyh1c2VySWQ6IHN0cmluZyk6IFByb21pc2U8UHJvZmlsZVtdPiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtEQVRBX0FQSV9CQVNFX1VSTH0vdXNlcnMvJHt1c2VySWR9L3Byb2ZpbGVzYClcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YClcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIHJldHVybiBkYXRhLnByb2ZpbGVzIHx8IFtdXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlciBwcm9maWxlczonLCBlcnJvcilcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG4vLyBUcmFuc2Zvcm0gQVBJIHVzZXIgdG8gUG9ydGFsIHVzZXIgZm9ybWF0XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtQXBpVXNlclRvUG9ydGFsVXNlcihhcGlVc2VyOiBVc2VyLCBpbmRleDogbnVtYmVyKTogYW55IHtcbiAgcmV0dXJuIHtcbiAgICBpZDogaW5kZXggKyAxLCAvLyBQb3J0YWwgZXhwZWN0cyBudW1lcmljIElEXG4gICAgdXNlcl9pZDogYXBpVXNlci51c2VyX2lkLCAvLyBLZWVwIG9yaWdpbmFsIEFQSSBJRCBmb3Igb3BlcmF0aW9uc1xuICAgIG5hbWU6IGFwaVVzZXIuZnVsbF9uYW1lLFxuICAgIGVtYWlsOiBhcGlVc2VyLmVtYWlsLFxuICAgIHBob25lOiBcIi1cIiwgLy8gTm90IGF2YWlsYWJsZSBpbiBBUEkgcmVzcG9uc2VcbiAgICBjb21wYW5pZXM6IGFwaVVzZXIuY29tcGFuaWVzX2NvdW50IHx8IDAsXG4gICAgcGVybWlzc2lvbnM6IGFwaVVzZXIudXNlcl9pZC5pbmNsdWRlcygnYWRtaW4nKSA/ICdBZG1pbmlzdHJhdG9yJyA6ICdVxbx5dGtvd25paycsIC8vIFNpbXBsaWZpZWQgbG9naWNcbiAgICBwcm9maWxlczogYXBpVXNlci5wcm9maWxlcyB8fCBbXSxcbiAgICBzdGF0dXM6IGFwaVVzZXIuc3RhdHVzID09PSAnYWN0aXZlJyxcbiAgfVxufVxuXG4vLyBJbnRlcmZhY2UgZm9yIHVzZXIgYXBwbGljYXRpb24gYWNjZXNzXG5leHBvcnQgaW50ZXJmYWNlIFVzZXJBcHBsaWNhdGlvbkFjY2VzcyB7XG4gIHVzZXJfaWQ6IHN0cmluZ1xuICBhcHBfaWQ6IHN0cmluZyAgXG4gIGFwcF9uYW1lOiBzdHJpbmdcbiAgcHJvZmlsZV9pZDogc3RyaW5nXG4gIHByb2ZpbGVfbmFtZTogc3RyaW5nXG4gIGFzc2lnbmVkX2F0OiBzdHJpbmdcbiAgYXNzaWduZWRfYnk/OiBzdHJpbmdcbn1cblxuLy8gRmV0Y2ggdXNlcidzIGFwcGxpY2F0aW9uIGFjY2VzcyAocmVhbCBkYXRhIGZyb20gQVBJKVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoVXNlckFwcGxpY2F0aW9uQWNjZXNzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyQXBwbGljYXRpb25BY2Nlc3NbXT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7REFUQV9BUElfQkFTRV9VUkx9L3VzZXJzLyR7dXNlcklkfS9hcHBsaWNhdGlvbi1hY2Nlc3NgKVxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKVxuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpXG4gICAgXG4gICAgLy8gUHJ6ZWtzenRhxYLEhyB6YWduaWXFvGTFvG9uZSBkYW5lIEFQSSBuYSBwxYJhc2vEhSBsaXN0xJlcbiAgICBjb25zdCBhcHBsaWNhdGlvbnMgPSBkYXRhLmFwcGxpY2F0aW9ucyB8fCBbXVxuICAgIGNvbnN0IGZsYXR0ZW5lZEFjY2VzczogVXNlckFwcGxpY2F0aW9uQWNjZXNzW10gPSBbXVxuICAgIFxuICAgIGFwcGxpY2F0aW9ucy5mb3JFYWNoKChhcHA6IGFueSkgPT4ge1xuICAgICAgYXBwLnByb2ZpbGVzPy5mb3JFYWNoKChwcm9maWxlOiBhbnkpID0+IHtcbiAgICAgICAgZmxhdHRlbmVkQWNjZXNzLnB1c2goe1xuICAgICAgICAgIHVzZXJfaWQ6IHVzZXJJZCxcbiAgICAgICAgICBhcHBfaWQ6IGFwcC5hcHBfaWQsXG4gICAgICAgICAgYXBwX25hbWU6IGFwcC5hcHBfbmFtZSxcbiAgICAgICAgICBwcm9maWxlX2lkOiBwcm9maWxlLnByb2ZpbGVfaWQsXG4gICAgICAgICAgcHJvZmlsZV9uYW1lOiBwcm9maWxlLnByb2ZpbGVfbmFtZSxcbiAgICAgICAgICBhc3NpZ25lZF9hdDogcHJvZmlsZS5hc3NpZ25lZF9hdCxcbiAgICAgICAgICBhc3NpZ25lZF9ieTogcHJvZmlsZS5hc3NpZ25lZF9ieVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9KVxuICAgIFxuICAgIHJldHVybiBmbGF0dGVuZWRBY2Nlc3NcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyB1c2VyIGFwcGxpY2F0aW9uIGFjY2VzczonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59XG5cbi8vIERlbGV0ZSB1c2VyIGFwcGxpY2F0aW9uIGFjY2VzcyBieSBwcm9maWxlX2lkXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGVsZXRlVXNlckFwcGxpY2F0aW9uQWNjZXNzKHVzZXJJZDogc3RyaW5nLCBwcm9maWxlSWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyBhcHBsaWNhdGlvbiBhY2Nlc3M6JywgeyB1c2VySWQsIHByb2ZpbGVJZCB9KVxuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7REFUQV9BUElfQkFTRV9VUkx9L3VzZXJzLyR7dXNlcklkfS9hcHBsaWNhdGlvbi1hY2Nlc3MvJHtwcm9maWxlSWR9YCwge1xuICAgICAgbWV0aG9kOiAnREVMRVRFJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKCdEZWxldGUgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cylcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIGRlbGV0ZSBhcHBsaWNhdGlvbiBhY2Nlc3MnKVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgIGNvbnNvbGUubG9nKCdEZWxldGUgc3VjY2VzczonLCByZXN1bHQpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdXNlciBhcHBsaWNhdGlvbiBhY2Nlc3M6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBVc2VyIGNvbXBhbnkgYWNjZXNzIGludGVyZmFjZVxuZXhwb3J0IGludGVyZmFjZSBVc2VyQ29tcGFueUFjY2VzcyB7XG4gIGNvbXBhbnlfaWQ6IHN0cmluZ1xuICBjb21wYW55X25hbWU6IHN0cmluZ1xuICBhc3NpZ25lZF9kYXRlOiBzdHJpbmdcbiAgbmlwPzogc3RyaW5nXG59XG5cbi8vIEZldGNoIHVzZXIgY29tcGFuaWVzXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZmV0Y2hVc2VyQ29tcGFuaWVzKHVzZXJJZDogc3RyaW5nKTogUHJvbWlzZTxVc2VyQ29tcGFueUFjY2Vzc1tdPiB7XG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0ZldGNoaW5nIHVzZXIgY29tcGFuaWVzIGZvciB1c2VyOicsIHVzZXJJZClcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH0vY29tcGFuaWVzYCwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGNvbnNvbGUubG9nKCdVc2VyIGNvbXBhbmllcyByZXNwb25zZSBzdGF0dXM6JywgcmVzcG9uc2Uuc3RhdHVzKVxuICAgIFxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGNvbnN0IGVycm9yRGF0YSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGF0YS5lcnJvciB8fCBlcnJvckRhdGEuZGV0YWlsIHx8ICdGYWlsZWQgdG8gZmV0Y2ggdXNlciBjb21wYW5pZXMnKVxuICAgIH1cblxuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICBjb25zb2xlLmxvZygnVXNlciBjb21wYW5pZXMgZmV0Y2hlZDonLCBkYXRhKVxuICAgIFxuICAgIC8vIE1hcCBBUEkgcmVzcG9uc2UgdG8gVXNlckNvbXBhbnlBY2Nlc3MgZm9ybWF0XG4gICAgY29uc3QgY29tcGFuaWVzID0gZGF0YS5jb21wYW5pZXMgfHwgW11cbiAgICByZXR1cm4gY29tcGFuaWVzLm1hcCgoY29tcGFueTogYW55KSA9PiAoe1xuICAgICAgY29tcGFueV9pZDogY29tcGFueS5jb21wYW55X2lkLFxuICAgICAgY29tcGFueV9uYW1lOiBjb21wYW55LmNvbXBhbnlfbmFtZSxcbiAgICAgIGFzc2lnbmVkX2RhdGU6IGNvbXBhbnkuYXNzaWduZWRfYXQsXG4gICAgICBuaXA6IGNvbXBhbnkubmlwXG4gICAgfSkpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgdXNlciBjb21wYW5pZXM6JywgZXJyb3IpXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxufVxuXG4vLyBEZWxldGUgdXNlciBjb21wYW55IGFjY2Vzc1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGRlbGV0ZVVzZXJDb21wYW55KHVzZXJJZDogc3RyaW5nLCBjb21wYW55SWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICB0cnkge1xuICAgIGNvbnNvbGUubG9nKCdEZWxldGluZyB1c2VyIGNvbXBhbnkgYWNjZXNzOicsIHsgdXNlcklkLCBjb21wYW55SWQgfSlcbiAgICBcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0RBVEFfQVBJX0JBU0VfVVJMfS91c2Vycy8ke3VzZXJJZH0vY29tcGFuaWVzLyR7Y29tcGFueUlkfWAsIHtcbiAgICAgIG1ldGhvZDogJ0RFTEVURScsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBjb25zb2xlLmxvZygnRGVsZXRlIGNvbXBhbnkgcmVzcG9uc2Ugc3RhdHVzOicsIHJlc3BvbnNlLnN0YXR1cylcbiAgICBcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICBjb25zdCBlcnJvckRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKClcbiAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvckRhdGEuZXJyb3IgfHwgZXJyb3JEYXRhLmRldGFpbCB8fCAnRmFpbGVkIHRvIGRlbGV0ZSB1c2VyIGNvbXBhbnkgYWNjZXNzJylcbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZygnVXNlciBjb21wYW55IGFjY2VzcyBkZWxldGVkIHN1Y2Nlc3NmdWxseScpXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgdXNlciBjb21wYW55IGFjY2VzczonLCBlcnJvcilcbiAgICB0aHJvdyBlcnJvclxuICB9XG59ICJdLCJuYW1lcyI6WyJEQVRBX0FQSV9CQVNFX1VSTCIsImZldGNoVXNlcnMiLCJyZXNwb25zZSIsImZldGNoIiwib2siLCJFcnJvciIsInN0YXR1cyIsImRhdGEiLCJqc29uIiwidXNlcnMiLCJtYXAiLCJ1c2VyIiwidXNlcl9pZCIsImlkIiwidXNlcm5hbWUiLCJuYW1lIiwiZnVsbF9uYW1lIiwiZW1haWwiLCJjcmVhdGVkX2F0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiY29tcGFuaWVzX2NvdW50IiwidGVuYW50cyIsImxlbmd0aCIsInByb2ZpbGVzIiwiZXJyb3IiLCJjb25zb2xlIiwiZmV0Y2hVc2VyIiwidXNlcklkIiwiZmV0Y2hBcHBsaWNhdGlvbnMiLCJkYXRhYmFzZV9hcHBsaWNhdGlvbnMiLCJjcmVhdGVVc2VyIiwidXNlckRhdGEiLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ1cGRhdGVVc2VyIiwiZGVsZXRlVXNlciIsImZldGNoUHJvZmlsZXMiLCJhcHBsaWNhdGlvbklkIiwidXJsIiwiZmV0Y2hQcm9maWxlIiwicHJvZmlsZUlkIiwicHJvZmlsZSIsImZldGNoQ29tcGFuaWVzRm9yVXNlcnMiLCJjb21wYW5pZXMiLCJhc3NpZ25Qcm9maWxlVG9Vc2VyIiwicHJvZmlsZV9pZCIsInJlbW92ZVByb2ZpbGVGcm9tVXNlciIsImFzc2lnbkNvbXBhbnlUb1VzZXIiLCJjb21wYW55SWQiLCJjb21wYW55X2lkIiwicmVtb3ZlQ29tcGFueUZyb21Vc2VyIiwiZmV0Y2hVc2VyUHJvZmlsZXMiLCJ0cmFuc2Zvcm1BcGlVc2VyVG9Qb3J0YWxVc2VyIiwiYXBpVXNlciIsImluZGV4IiwicGhvbmUiLCJwZXJtaXNzaW9ucyIsImluY2x1ZGVzIiwiZmV0Y2hVc2VyQXBwbGljYXRpb25BY2Nlc3MiLCJhcHBsaWNhdGlvbnMiLCJmbGF0dGVuZWRBY2Nlc3MiLCJmb3JFYWNoIiwiYXBwIiwicHVzaCIsImFwcF9pZCIsImFwcF9uYW1lIiwicHJvZmlsZV9uYW1lIiwiYXNzaWduZWRfYXQiLCJhc3NpZ25lZF9ieSIsImRlbGV0ZVVzZXJBcHBsaWNhdGlvbkFjY2VzcyIsImxvZyIsImVycm9yRGF0YSIsImRldGFpbCIsInJlc3VsdCIsImZldGNoVXNlckNvbXBhbmllcyIsImNvbXBhbnkiLCJjb21wYW55X25hbWUiLCJhc3NpZ25lZF9kYXRlIiwibmlwIiwiZGVsZXRlVXNlckNvbXBhbnkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./lib/users-api.ts\n"));

/***/ })

});